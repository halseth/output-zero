use std::fs::File;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{METHOD_ELF, METHOD_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts, Receipt};

use bitcoin_hashes::sha256;
use bitcoin_hashes::Hash as BitcoinHash;

use clap::Parser;

use rustreexo::accumulator::node_hash::NodeHash;
use rustreexo::accumulator::stump::Stump;
use std::str::FromStr;
use std::time::SystemTime;

use bitcoin::consensus::deserialize;
use bitcoin::key::{Keypair, UntweakedPublicKey};
use bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing, Verification};
use bitcoin::{Address, BlockHash, Network, PrivateKey, ScriptBuf, Transaction, XOnlyPublicKey};
use clap::builder::TypedValueParser;
use k256::schnorr;
use k256::schnorr::signature::Verifier;
use rustreexo::accumulator::proof::Proof;
use serde::{Deserialize, Serialize};

use k256::PublicKey;
use musig2::{
    AggNonce, FirstRound, KeyAggContext, PartialSignature, PubNonce, SecNonce, SecNonceSpices,
    SecondRound,
};
use sha2::{Digest, Sha512_256};
use shared::{aggregate_keys, get_leaf_hashes, sort_keypairs, sort_pubkeys, verify_musig};

fn gen_keypair<C: Signing>(secp: &Secp256k1<C>) -> Keypair {
    let sk = SecretKey::new(&mut rand::thread_rng());
    Keypair::from_secret_key(secp, &sk)
}

/// utxozkp
#[derive(Debug, Parser)]
#[command(verbatim_doc_comment)]
struct Args {
    #[arg(short, long, default_value_t = false)]
    prove: bool,

    #[arg(long)]
    proof_type: Option<String>,

    /// File containing a receipt to verify or file to write receipt to.
    #[arg(short, long)]
    receipt_file: Option<String>,

    #[arg(long)]
    utreexo_proof: Option<String>,

    #[arg(long)]
    utreexo_acc: Option<String>,

    #[arg(long)]
    leaf_hash: Option<String>,

    #[arg(long)]
    tx_hex: Option<String>,

    #[arg(long)]
    block_height: Option<u32>,

    #[arg(long)]
    block_hash: Option<String>,

    #[arg(long)]
    vout: Option<u32>,

    #[arg(long)]
    msg_hex: Option<String>,

    #[arg(long)]
    musig_sig: Option<String>,

    #[arg(long)]
    node_key_1_priv: Option<String>,

    #[arg(long)]
    node_key_2_priv: Option<String>,

    #[arg(long)]
    bitcoin_key_1_priv: Option<String>,

    #[arg(long)]
    bitcoin_key_2_priv: Option<String>,

    #[arg(long)]
    node_key_1: Option<String>,

    #[arg(long)]
    node_key_2: Option<String>,

    #[arg(long)]
    bitcoin_key_1: Option<String>,

    #[arg(long)]
    bitcoin_key_2: Option<String>,

    /// Network to use.
    #[arg(long, default_value_t = Network::Testnet)]
    network: Network,
}

#[derive(Deserialize, Serialize)]
struct CliProof {
    pub targets: Vec<u64>,
    pub hashes: Vec<String>,
}

#[derive(Deserialize, Serialize)]
struct CliStump {
    pub roots: Vec<String>,
    pub leaves: u64,
}

fn parse_pubkey(pub_str: &str) -> PublicKey {
    let pk_bytes = hex::decode(pub_str).unwrap();
    let pk = PublicKey::from_sec1_bytes(&pk_bytes).unwrap();

    println!("sec1 pub: {}", hex::encode(pk_bytes));

    pk
}

fn extract_keypair<C: Signing + Verification>(
    secp: &Secp256k1<C>,
    priv_str: &str,
    network: Network,
) -> Keypair {
    let keypair = if priv_str == "new" {
        gen_keypair(&secp)
    } else {
        let sk = SecretKey::from_str(&priv_str).unwrap();
        Keypair::from_secret_key(&secp, &sk)
    };

    let (internal_key, _parity) = keypair.x_only_public_key();
    let script_buf = ScriptBuf::new_p2tr(&secp, internal_key, None);
    let addr = Address::from_script(script_buf.as_script(), network).unwrap();
    let pubkey = keypair.public_key();
    println!("priv: {}", hex::encode(keypair.secret_key().secret_bytes()));
    println!("pubkey: {}", hex::encode(pubkey.serialize()));
    println!("xonly pub: {}", internal_key);
    println!("address: {}", addr);

    keypair
}

fn address<C: Verification>(secp: &Secp256k1<C>, pubkey: PublicKey, network: Network) {
    let pub_bytes: [u8; 32] = pubkey.to_sec1_bytes()[1..].try_into().unwrap();
    let pubx = XOnlyPublicKey::from_slice(&pub_bytes).unwrap();

    let script_buf = ScriptBuf::new_p2tr(&secp, pubx, None);
    let addr = Address::from_script(script_buf.as_script(), network).unwrap();
    println!("pub: {}", pubx);
    println!("address: {}", addr);
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let args = Args::parse();

    let receipt_file = if args.prove {
        let r = File::create(args.receipt_file.unwrap()).unwrap();
        r
    } else {
        let r = File::open(args.receipt_file.unwrap()).unwrap();
        r
    };

    // If not proving, simply verify the passed receipt using the loaded utxo set.
    let start_time = SystemTime::now();
    if !args.prove {
        let receipt: Receipt = bincode::deserialize_from(receipt_file).unwrap();
        verify_receipt(&receipt);
        println!("receipt verified in {:?}", start_time.elapsed().unwrap());
        return;
    }

    let secp = Secp256k1::new();
    let network = args.network;

    let mut keypairs = vec![];

    println!("node_key_1:");
    let pub_node1 = match args.node_key_1_priv {
        Some(priv_str) => {
            let kp = extract_keypair(&secp, &priv_str, network);
            keypairs.push(kp);
            PublicKey::from_sec1_bytes(&kp.public_key().serialize()).unwrap()
        }
        None => parse_pubkey(&args.node_key_1.unwrap()),
    };

    println!("node_key_2:");
    let pub_node2 = match args.node_key_2_priv {
        Some(priv_str) => {
            let kp = extract_keypair(&secp, &priv_str, network);
            keypairs.push(kp);
            PublicKey::from_sec1_bytes(&kp.public_key().serialize()).unwrap()
        }
        None => parse_pubkey(&args.node_key_2.unwrap()),
    };

    println!("bitcoin_key_1:");
    let pub_bitcoin1 = match args.bitcoin_key_1_priv {
        Some(priv_str) => {
            let kp = extract_keypair(&secp, &priv_str, network);
            keypairs.push(kp);
            PublicKey::from_sec1_bytes(&kp.public_key().serialize()).unwrap()
        }
        None => parse_pubkey(&args.bitcoin_key_1.unwrap()),
    };

    println!("bitcoin_key_2:");
    let pub_bitcoin2 = match args.bitcoin_key_2_priv {
        Some(priv_str) => {
            let kp = extract_keypair(&secp, &priv_str, network);
            keypairs.push(kp);
            PublicKey::from_sec1_bytes(&kp.public_key().serialize()).unwrap()
        }
        None => parse_pubkey(&args.bitcoin_key_2.unwrap()),
    };

    sort_keypairs(&mut keypairs);

    let msg_to_sign = hex::decode(args.msg_hex.unwrap()).unwrap();

    let all_pubs = vec![pub_node1, pub_node2, pub_bitcoin1, pub_bitcoin2];
    let mut musig_pubs = all_pubs.clone();
    sort_pubkeys(&mut musig_pubs);

    let mut bitcoin_pubs = vec![pub_bitcoin1, pub_bitcoin2];
    sort_pubkeys(&mut bitcoin_pubs);

    for i in 0..musig_pubs.len() {
        println!("key[{}]={}", i, hex::encode(musig_pubs[i].to_sec1_bytes()));
    }

    let tap_key = aggregate_keys(bitcoin_pubs);
    let tap_bytes = tap_key.to_sec1_bytes();
    println!("tap key : {}", hex::encode(&tap_bytes));
    address(&secp, tap_key, network);

    let musig_sig = match args.musig_sig {
        Some(musig_sig) => hex::decode(musig_sig).unwrap(),

        // In case no signature is provided, we assume we are signing the message and private keys
        // are available,
        None => {
            println!("signing");
            let (_, sig) = create_musig(keypairs, &msg_to_sign);
            sig.to_vec()
        }
    };

    println!("musig sig: {}", hex::encode(&musig_sig));

    assert_eq!(
        verify_musig(
            musig_pubs.clone(),
            musig_sig.clone().try_into().unwrap(),
            &msg_to_sign
        ),
        true,
    );

    println!("musig successfully verified");


    let acc: CliStump = serde_json::from_str(&args.utreexo_acc.unwrap()).unwrap();
    let acc = Stump {
        leaves: acc.leaves,
        roots: acc
            .roots
            .into_iter()
            .map(|root| NodeHash::from_str(&root).expect("invalid hash"))
            .collect(),
    };




    let proof_type: ProverOpts = match args.proof_type.as_deref() {
        None => {
            println!("using default proof type");
            ProverOpts::default()
        }
        Some("default") => {
            println!("using default proof type");
            ProverOpts::default()
        }
        Some("fast") => {
            println!("using fast proof type");
            ProverOpts::fast()
        }
        Some("succint") => {
            println!("using succint proof type");
            ProverOpts::succinct()
        }
        Some("groth16") => {
            println!("using groth16 proof type");
            ProverOpts::groth16()
        }
        Some("composite") => {
            println!("using composite proof type");
            ProverOpts::composite()
        }
        _ => {
            println!("proof type invalid");
            return;
        }
    };

    let proof: CliProof = serde_json::from_str(&args.utreexo_proof.unwrap()).unwrap();
    let proof = Proof {
        targets: proof.targets,
        hashes: proof
            .hashes
            .into_iter()
            .map(|root| NodeHash::from_str(&root).expect("invalid hash"))
            .collect(),
    };

    let leaf_hash = NodeHash::from_str(&args.leaf_hash.unwrap()).unwrap();

    let tx_bytes = hex::decode(&args.tx_hex.unwrap()).unwrap();
    let tx: Transaction = deserialize(&tx_bytes).unwrap();

    let vout = args.vout.unwrap();
    let block_height = args.block_height.unwrap();
    let block_hash: BlockHash = BlockHash::from_str(&args.block_hash.unwrap()).unwrap();

    let lh = get_leaf_hashes(&tx, vout, block_height, block_hash);
    println!("lh: {:?}", lh);

    let lh = NodeHash::from(lh);

    assert_eq!(lh, leaf_hash);

    // We will prove inclusion in the UTXO set of the key we control.
    let internal_key = XOnlyPublicKey::from_slice(&tap_bytes[1..]).unwrap();
    println!("xonly tap key: {}", hex::encode(internal_key.serialize()));

    let script_pubkey = ScriptBuf::new_p2tr(&secp, internal_key, None);

    assert_eq!(tx.output[vout as usize].script_pubkey, script_pubkey);

    println!("proving {}", leaf_hash);
    println!("proof: {:?}", proof);
    assert_eq!(acc.verify(&proof, &[leaf_hash]), Ok(true));
    println!("stump proof verified");

    let start_time = SystemTime::now();
    let env = ExecutorEnv::builder()
        .write(&msg_to_sign)
        .unwrap()
        .write(&acc)
        .unwrap()
        .write(&proof)
        .unwrap()
        .write(&tx)
        .unwrap()
        .write(&vout)
        .unwrap()
        .write(&block_height)
        .unwrap()
        .write(&block_hash)
        .unwrap()
        .write(&all_pubs)
        .unwrap()
        .write(&musig_sig.as_slice())
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove_with_opts(env, METHOD_ELF, &proof_type)
        .unwrap();
    println!("Proving took {:?}", start_time.elapsed().unwrap());

    // extract the receipt.
    let receipt = prove_info.receipt;

    verify_receipt(&receipt, &acc);

    let seal_size = receipt.seal_size();

    let receipt_bytes = bincode::serialize(&receipt).unwrap();
    println!("receipt ({}). seal size: {seal_size}.", receipt_bytes.len());

    bincode::serialize_into(receipt_file, &receipt).unwrap();
}

fn verify_receipt(receipt: &Receipt, s: &Stump) {
    let (node_key1, node_key2, stump_hash, pk_hash, msg): (PublicKey, PublicKey, String, String, Vec<u8>) = receipt.journal.decode().unwrap();

    let mut hasher = Sha512_256::new();
    s.serialize(&mut hasher).unwrap();
    let h = hex::encode(hasher.finalize());

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    println!("committed node_key1 : {}", hex::encode(&node_key1.to_sec1_bytes()));
    println!("committed node_key2 : {}", hex::encode(&node_key2.to_sec1_bytes()));
    println!("bitcoin keys hash: {}", pk_hash);
    println!("signed msg: {}", hex::encode(msg));
    println!("stump hash: {}", stump_hash);

    assert_eq!(stump_hash, h, "stumps not equal");
    receipt.verify(METHOD_ID).unwrap();
}
fn create_musig(keys: Vec<Keypair>, message: &Vec<u8>) -> (Vec<PublicKey>, [u8; 64]) {
    let mut pubs: Vec<PublicKey> = Vec::new();

    for kp in keys.clone() {
        let bytes = kp.secret_key().secret_bytes();
        let str = hex::encode(bytes);
        let scalar: musig2::secp::Scalar = str.parse().unwrap();
        let p = scalar.base_point_mul();
        let pubkey = PublicKey::from(p);
        pubs.push(pubkey.into());
    }

    let key_agg_ctx = KeyAggContext::new(pubs.clone()).unwrap();

    for kp in keys.clone() {
        let bytes = kp.secret_key().secret_bytes();
        let str = hex::encode(bytes);
        println!("priv key: {}", str);
        let scalar: musig2::secp::Scalar = str.parse().unwrap();
        let p = scalar.base_point_mul();
        println!("point: {}", hex::encode(p.serialize()));
        key_agg_ctx.key_coefficient(p).unwrap();
    }

    // This is the key which the group has control over.
    let aggregated_pubkey: PublicKey = key_agg_ctx.aggregated_pubkey();

    println!("all good {:?}", aggregated_pubkey);

    let nonce_seed = [0xACu8; 32];

    // This is how `FirstRound` derives the nonce internally.
    let mut public_nonces = Vec::new();
    let mut sec_nonces = Vec::new();
    for (i, k) in pubs.iter().enumerate() {
        let secnonce = SecNonce::build(nonce_seed)
            //       .with_seckey(scalar)
            .with_pubkey(pubs[i].clone())
            .with_message(&message)
            .with_aggregated_pubkey(aggregated_pubkey)
            .with_extra_input(&(i as u32).to_be_bytes())
            .build();

        sec_nonces.push(secnonce.clone());
        let our_public_nonce = secnonce.public_nonce();

        public_nonces.push(our_public_nonce);
    }

    // We manually aggregate the nonces together and then construct our partial signature.
    let aggregated_nonce: AggNonce = public_nonces.iter().sum();
    let mut partial_signatures = Vec::new();
    for (i, k) in keys.clone().iter().enumerate() {
        //    let sk = bitcoin::secp256k1::SecretKey::from_str(&k).unwrap();
        let b = k.secret_bytes();
        let priv_str = hex::encode(b);
        let scalar: musig2::secp::Scalar = priv_str.parse().unwrap();

        let our_partial_signature: PartialSignature = musig2::sign_partial(
            &key_agg_ctx,
            scalar,
            sec_nonces[i].clone(),
            &aggregated_nonce,
            &message,
        )
        .expect("error creating partial signature");

        partial_signatures.push(our_partial_signature);
    }

    /// Signatures should be verified upon receipt and invalid signatures
    /// should be blamed on the signer who sent them.
    for (i, partial_signature) in partial_signatures.clone().into_iter().enumerate() {
        let their_pubkey: PublicKey = key_agg_ctx.get_pubkey(i).unwrap();
        let their_pubnonce = &public_nonces[i];

        musig2::verify_partial(
            &key_agg_ctx,
            partial_signature,
            &aggregated_nonce,
            their_pubkey,
            their_pubnonce,
            &message,
        )
        .expect("received invalid signature from a peer");
    }

    let final_signature: [u8; 64] = musig2::aggregate_partial_signatures(
        &key_agg_ctx,
        &aggregated_nonce,
        partial_signatures,
        &message,
    )
    .expect("error aggregating signatures");

    musig2::verify_single(aggregated_pubkey, &final_signature, &message)
        .expect("aggregated signature must be valid");

    (pubs, final_signature)
}
