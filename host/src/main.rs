use std::fs::File;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{METHOD_ELF, METHOD_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};

use sha2::{Digest, Sha512_256};
use std::io::Write;

use bitcoin_hashes::sha256;
use bitcoin_hashes::Hash as BitcoinHash;

use clap::Parser;

use rustreexo::accumulator::node_hash::NodeHash;
use rustreexo::accumulator::stump::Stump;
use std::str::FromStr;
use std::time::SystemTime;

use bitcoin::consensus::{deserialize, Encodable};
use bitcoin::key::Keypair;
use bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing};
use bitcoin::{Address, BlockHash, Network, ScriptBuf, Transaction};
use k256::schnorr;
use k256::schnorr::signature::Verifier;
use rustreexo::accumulator::proof::Proof;
use serde::{Deserialize, Serialize};

fn gen_keypair<C: Signing>(secp: &Secp256k1<C>) -> Keypair {
    let sk = SecretKey::new(&mut rand::thread_rng());
    Keypair::from_secret_key(secp, &sk)
}

/// utxozkp
#[derive(Debug, Parser)]
#[command(verbatim_doc_comment)]
struct Args {
    #[arg(short, long, default_value_t = false)]
    prove: bool,

    /// File containing a receipt to verify or file to write receipt to.
    #[arg(short, long)]
    receipt_file: Option<String>,

    #[arg(long)]
    utreexo_proof: Option<String>,

    #[arg(long)]
    utreexo_acc: Option<String>,

    #[arg(long)]
    leaf_hash: Option<String>,

    #[arg(long)]
    tx_hex: Option<String>,

    #[arg(long)]
    block_height: Option<u32>,

    #[arg(long)]
    block_hash: Option<String>,

    #[arg(long)]
    vout: Option<u32>,

    /// Message to sign.
    #[arg(short, long)]
    msg: Option<String>,

    /// Sign the message using the given private key. Pass "new" to generate one at random. Leave
    /// this blank if verifying a receipt.
    #[arg(long)]
    priv_key: Option<String>,

    /// Network to use.
    #[arg(long, default_value_t = Network::Testnet)]
    network: Network,
}

#[derive(Deserialize, Serialize)]
struct CliProof {
    pub targets: Vec<u64>,
    pub hashes: Vec<String>,
}

#[derive(Deserialize, Serialize)]
struct CliStump {
    pub roots: Vec<String>,
    pub leaves: u64,
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let args = Args::parse();

    let secp = Secp256k1::new();
    let network = args.network;

    // Generate a new keypair or use the given private key.
    let keypair = match args.priv_key.as_deref() {
        Some(priv_str) => {
            let keypair = if priv_str == "new" {
                gen_keypair(&secp)
            } else {
                let sk = SecretKey::from_str(&priv_str).unwrap();
                Keypair::from_secret_key(&secp, &sk)
            };

            let (internal_key, _parity) = keypair.x_only_public_key();
            let script_buf = ScriptBuf::new_p2tr(&secp, internal_key, None);
            let addr = Address::from_script(script_buf.as_script(), network).unwrap();
            println!("priv: {}", hex::encode(keypair.secret_key().secret_bytes()));
            println!("pub: {}", internal_key);
            println!("address: {}", addr);

            if priv_str == "new" {
                return;
            }

            Some(keypair)
        }
        _ => {
            if args.prove {
                println!("priv key needed");
                return;
            }
            None
        }
    };

    let receipt_file = if args.prove {
        let r = File::create(args.receipt_file.unwrap()).unwrap();
        r
    } else {
        let r = File::open(args.receipt_file.unwrap()).unwrap();
        r
    };

    let acc: CliStump = serde_json::from_str(&args.utreexo_acc.unwrap()).unwrap();
    let acc = Stump {
        leaves: acc.leaves,
        roots: acc
            .roots
            .into_iter()
            .map(|root| NodeHash::from_str(&root).expect("invalid hash"))
            .collect(),
    };

    let start_time = SystemTime::now();

    // If not proving, simply verify the passed receipt using the loaded utxo set.
    if !args.prove {
        let receipt: Receipt = bincode::deserialize_from(receipt_file).unwrap();
        verify_receipt(&receipt, &acc);
        println!("receipt verified in {:?}", start_time.elapsed().unwrap());
        return;
    }

    let msg_to_sign = args.msg.unwrap();
    let msg_bytes = msg_to_sign.as_bytes();
    let digest = sha256::Hash::hash(msg_bytes);
    let digest_bytes = digest.to_byte_array();
    let msg = Message::from_digest(digest_bytes);

    let proof: CliProof = serde_json::from_str(&args.utreexo_proof.unwrap()).unwrap();
    let proof = Proof {
        targets: proof.targets,
        hashes: proof
            .hashes
            .into_iter()
            .map(|root| NodeHash::from_str(&root).expect("invalid hash"))
            .collect(),
    };

    let leaf_hash = NodeHash::from_str(&args.leaf_hash.unwrap()).unwrap();

    let tx_bytes = hex::decode(&args.tx_hex.unwrap()).unwrap();
    let tx: Transaction = deserialize(&tx_bytes).unwrap();

    let vout = args.vout.unwrap();
    let block_height = args.block_height.unwrap();
    let block_hash: BlockHash = BlockHash::from_str(&args.block_hash.unwrap()).unwrap();

    let lh = get_leaf_hashes(&tx, vout, block_height, block_hash);
    println!("lh: {:?}", lh);

    let lh = NodeHash::from(lh);

    assert_eq!(lh, leaf_hash);

    // We will prove inclusion in the UTXO set of the key we control.
    let (internal_key, _parity) = keypair.unwrap().x_only_public_key();
    let priv_bytes = keypair.unwrap().secret_key().secret_bytes();
    let priv_key = schnorr::SigningKey::from_bytes(&priv_bytes).unwrap();
    let script_pubkey = ScriptBuf::new_p2tr(&secp, internal_key, None);

    println!("proving {}", leaf_hash);
    println!("proof: {:?}", proof);
    assert_eq!(acc.verify(&proof, &[leaf_hash]), Ok(true));
    println!("stump proof verified");

    // Sign using the tweaked key.
    let sig = secp.sign_schnorr(&msg, &keypair.unwrap());

    // Verify signature.
    let (pubkey, _) = keypair.unwrap().x_only_public_key();
    println!("pubkey: {}", pubkey);

    let sig_bytes = sig.serialize();
    println!("secp signature: {}", hex::encode(sig_bytes));
    secp.verify_schnorr(&sig, &msg, &pubkey)
        .expect("secp verification failed");

    let pub_bytes = pubkey.serialize();

    println!("creating verifying key");
    let verifying_key = schnorr::VerifyingKey::from_bytes(&pub_bytes).unwrap();
    println!(
        "created verifying key: {}",
        hex::encode(verifying_key.to_bytes())
    );

    let schnorr_sig = schnorr::Signature::try_from(sig_bytes.as_slice()).unwrap();
    println!("schnorr signature: {}", hex::encode(schnorr_sig.to_bytes()));

    verifying_key
        .verify(msg_bytes, &schnorr_sig)
        .expect("schnorr verification failed");

    let start_time = SystemTime::now();
    let env = ExecutorEnv::builder()
        .write(&msg_bytes)
        .unwrap()
        .write(&priv_key)
        .unwrap()
        .write(&leaf_hash)
        .unwrap()
        .write(&acc)
        .unwrap()
        .write(&proof)
        .unwrap()
        .write(&sig_bytes.as_slice())
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, METHOD_ELF).unwrap();
    println!("Proving took {:?}", start_time.elapsed().unwrap());

    // extract the receipt.
    let receipt = prove_info.receipt;

    verify_receipt(&receipt, &acc);

    let receipt_bytes = bincode::serialize(&receipt).unwrap();
    println!("receipt ({})", receipt_bytes.len(),);

    bincode::serialize_into(receipt_file, &receipt).unwrap();
}

fn verify_receipt(receipt: &Receipt, s: &Stump) {
    let (receipt_stump, sk_hash, msg): (Stump, String, String) = receipt.journal.decode().unwrap();

    assert_eq!(&receipt_stump, s, "stumps not equal");

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(METHOD_ID).unwrap();
    println!("priv key hash: {}", sk_hash);
    println!("signed msg: {}", msg);
}

pub const UTREEXO_TAG_V1: [u8; 64] = [
    0x5b, 0x83, 0x2d, 0xb8, 0xca, 0x26, 0xc2, 0x5b, 0xe1, 0xc5, 0x42, 0xd6, 0xcc, 0xed, 0xdd, 0xa8,
    0xc1, 0x45, 0x61, 0x5c, 0xff, 0x5c, 0x35, 0x72, 0x7f, 0xb3, 0x46, 0x26, 0x10, 0x80, 0x7e, 0x20,
    0xae, 0x53, 0x4d, 0xc3, 0xf6, 0x42, 0x99, 0x19, 0x99, 0x31, 0x77, 0x2e, 0x03, 0x78, 0x7d, 0x18,
    0x15, 0x6e, 0xb3, 0x15, 0x1e, 0x0e, 0xd1, 0xb3, 0x09, 0x8b, 0xdc, 0x84, 0x45, 0x86, 0x18, 0x85,
];

fn get_leaf_hashes(
    transaction: &Transaction,
    vout: u32,
    height: u32,
    block_hash: BlockHash,
) -> sha256::Hash {
    let header_code = height << 1;

    let mut ser_utxo = Vec::new();
    let utxo = transaction.output.get(vout as usize).unwrap();
    utxo.consensus_encode(&mut ser_utxo).unwrap();
    let header_code = if transaction.is_coinbase() {
        header_code | 1
    } else {
        header_code
    };
    let txid = transaction.txid();
    println!("txid: {txid}, block_hash: {block_hash} vout: {vout} height: {height}");

    let leaf_hash = Sha512_256::new()
        .chain_update(UTREEXO_TAG_V1)
        .chain_update(UTREEXO_TAG_V1)
        .chain_update(block_hash)
        .chain_update(transaction.txid())
        .chain_update(vout.to_le_bytes())
        .chain_update(header_code.to_le_bytes())
        .chain_update(ser_utxo)
        .finalize();
    sha256::Hash::from_slice(leaf_hash.as_slice()).expect("parent_hash: Engines shouldn't be Err")
}
