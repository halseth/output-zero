use std::fs::File;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{METHOD_ELF, METHOD_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};

use sha2::{Digest, Sha512_256};
use std::io::Write;

use bitcoin_hashes::sha256;
use bitcoin_hashes::Hash as BitcoinHash;

use clap::Parser;
use txoutset::{ComputeAddresses, Dump};

use std::str::FromStr;
use std::time::SystemTime;
use rustreexo::accumulator::node_hash::NodeHash;
use rustreexo::accumulator::stump::Stump;

use bitcoin::address::Payload;
use bitcoin::consensus::encode::serialize;
use bitcoin::key::Keypair;
use bitcoin::secp256k1::schnorr::Signature;
use bitcoin::secp256k1::{rand, Message, Scalar, Secp256k1, SecretKey, Signing, Verification};
use bitcoin::WitnessVersion::V1;
use bitcoin::{Address, Amount, Network, ScriptBuf, TxOut, XOnlyPublicKey};
use rustreexo::accumulator::pollard::Pollard;
use Payload::WitnessProgram;

fn gen_keypair<C: Signing>(secp: &Secp256k1<C>) -> Keypair {
    let sk = SecretKey::new(&mut rand::thread_rng());
    Keypair::from_secret_key(secp, &sk)
}

/// utxozkp
#[derive(Debug, Parser)]
#[command(verbatim_doc_comment)]
struct Args {
    /// File containing the results of Bitcoin Core RPC `dumptxoutset`
    #[arg(short, long)]
    utxoset_file: Option<String>,

    #[arg(short, long, default_value_t = false)]
    prove: bool,

    /// File containing a receipt to verify or file to write receipt to.
    #[arg(short, long)]
    receipt_file: Option<String>,

    #[arg(short, long)]
    utreexo_file: Option<String>,

    /// Message to sign.
    #[arg(short, long)]
    msg: Option<String>,

    /// Sign the message using the given private key. Pass "new" to generate one at random. Leave
    /// this blank if verifying a receipt.
    #[arg(short, long)]
    priv_key: Option<String>,


    /// Network to use.
    #[arg(long, default_value_t = Network::Testnet)]
    network: Network,
}

fn create_nodehash(script_buf: ScriptBuf) -> NodeHash {
    // Simple node hash representation: hash the script pubkey. In a real application one would use
    // the regular utreexo serialization, which contains more info about the UTXO.
    let txout = TxOut {
        value: Amount::ZERO,
        script_pubkey: script_buf,
    };

    // Serialize the TxOut using bitcoin::consensus::encode::serialize
    let serialized_txout = serialize(&txout);
    let mut hasher = Sha512_256::new();
    hasher.update(&serialized_txout);

    let result = hasher.finalize();
    let hash = NodeHash::from_str(hex::encode(result).as_str()).unwrap();

    hash
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let args = Args::parse();

    let secp = Secp256k1::new();
    let network = args.network;

    // Generate a new keypair or use the given private key.
    let keypair = match args.priv_key.as_deref() {
        Some(priv_str) => {
            let keypair = if priv_str == "new" {
                gen_keypair(&secp)
            } else {
                let sk = SecretKey::from_str(&priv_str).unwrap();
                Keypair::from_secret_key(&secp, &sk)
            };

            let (internal_key, _parity) = keypair.x_only_public_key();
            let script_buf = ScriptBuf::new_p2tr(&secp, internal_key, None);
            let addr = Address::from_script(script_buf.as_script(), network).unwrap();
            println!("priv: {}", hex::encode(keypair.secret_key().secret_bytes()));
            println!("pub: {}", internal_key);
            println!("address: {}", addr);

            if priv_str == "new" {
                return;
            }

            Some(keypair)
        }
        _ => {
            if args.prove {
                println!("priv key needed");
                return;
            }
            None
        }
    };

    let (receipt_file, stump_file) = if args.prove {
        let r = File::create(args.receipt_file.unwrap()).unwrap();
        let s = File::create(args.utreexo_file.unwrap()).unwrap();
        (r, s)
    } else {
        let r = File::open(args.receipt_file.unwrap()).unwrap();
        let s = File::open(args.utreexo_file.unwrap()).unwrap();
        (r, s)
    };

    let msg_to_sign = args.msg.unwrap();
    let digest = sha256::Hash::hash(msg_to_sign.as_bytes());
    let msg = Message::from_digest(digest.to_byte_array());

    let start_time = SystemTime::now();

    // If not proving, simply verify the passed receipt using the loaded utxo set.
    if !args.prove {
        let receipt: Receipt = bincode::deserialize_from(receipt_file).unwrap();
        let s: Stump = bincode::deserialize_from(stump_file).unwrap();
        verify_receipt(secp, &receipt, &s, msg);
        println!("receipt verified in {:?}", start_time.elapsed().unwrap());
        return;
    }


    // Our Utreexo accumulator.
    let mut p = Pollard::new();

    let compute_addresses = ComputeAddresses::Yes(network);
    match Dump::new(&args.utxoset_file.unwrap(), compute_addresses) {
        Ok(dump) => {
            println!(
                "Dump opened.\n Block Hash: {}\n UTXO Set Size: {}",
                dump.block_hash, dump.utxo_set_size
            );

            let mut i = 0;
            let n = dump.utxo_set_size;
            let mut num_taproot = 0;
            for item in dump {
                i += 1;

                if i % 500000 == 0 {
                    println!(
                        "{}/{} ({:.2}%)\ttaproot: {}/{} ({:.2}%)",
                        i,
                        n,
                        100.0 * (i as f64) / (n as f64),
                        num_taproot,
                        i,
                        100.0 * (num_taproot as f64) / (i as f64)
                    );
                }

                match item.address {
                    Some(ref address) => {
                        let payload = address.payload();

                        // We only care about taproot outputs.
                        match payload {
                            WitnessProgram(w) => {
                                if w.version() == V1 {
                                    let hash = create_nodehash(item.script_pubkey);
                                    p.modify(&[hash], &[]).unwrap();
                                    num_taproot += 1;
                                }
                            }
                            _ => {}
                        }
                    }
                    _ => {}
                }
            }
        }
        Err(e) => {
            _ = writeln!(std::io::stderr(), "{}", e);
            return;
        }
    }

    println!("Reading UTXO dump took {:?}", start_time.elapsed().unwrap());

    let roots = p
        .get_roots()
        .iter()
        .map(|root| root.get_data())
        .collect::<Vec<_>>();

    // Create a lightweight stump to use int the ZK environment.
    let s = Stump {
        roots,
        leaves: p.leaves,
    };

    // We will prove inclusion in the UTXO set of the key we control.
    let (internal_key, _parity) = keypair.unwrap().x_only_public_key();
    let script_pubkey = ScriptBuf::new_p2tr(&secp, internal_key, None);
    let myhash = create_nodehash(script_pubkey);

    println!("proving {}", myhash);
    let proof = p.prove(&[myhash]).unwrap();
    println!("proof: {:?}", proof);
    assert_eq!(p.verify(&proof, &[myhash]), Ok(true));
    println!("pollard proof verified");
    assert_eq!(s.verify(&proof, &[myhash]), Ok(true));
    println!("stump proof verified");

    // To avoid leaking the key we are signing for, we tweak it using a random value.
    let rnd = SecretKey::new(&mut rand::thread_rng());
    let blinding_scalar = Scalar::from_be_bytes(rnd.secret_bytes()).unwrap();
    let blinded_key = keypair.unwrap().add_xonly_tweak(&secp, &blinding_scalar).unwrap();

    // Sign using the tweaked key.
    let sig = secp.sign_schnorr(&msg, &blinded_key);

    let start_time = SystemTime::now();
    let env = ExecutorEnv::builder()
        .write(&s)
        .unwrap()
        .write(&proof)
        .unwrap()
        .write(&internal_key)
        .unwrap()
        .write(&blinding_scalar.to_be_bytes())
        .unwrap()
        .write(&sig)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, METHOD_ELF).unwrap();
    println!("Proving took {:?}", start_time.elapsed().unwrap());

    // extract the receipt.
    let receipt = prove_info.receipt;

    verify_receipt(secp, &receipt, &s, msg);

    let receipt_bytes = bincode::serialize(&receipt).unwrap();
    println!("receipt ({})", receipt_bytes.len(),);

    bincode::serialize_into(receipt_file, &receipt).unwrap();
    bincode::serialize_into(stump_file, &s).unwrap();
}

fn verify_receipt<C: Verification>(secp: Secp256k1<C>, receipt: &Receipt, s: &Stump, msg: Message) {
    let (receipt_stump, receipt_sig, receipt_pubkey): (Stump, Signature, XOnlyPublicKey) =
        receipt.journal.decode().unwrap();

    assert_eq!(&receipt_stump, s, "stumps not equal");

    // Check that the signature is valid using the key from the receipt.
    assert_eq!(
        secp.verify_schnorr(&receipt_sig, &msg, &receipt_pubkey),
        Ok(()),
        "invalid signature"
    );

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(METHOD_ID).unwrap();
}
